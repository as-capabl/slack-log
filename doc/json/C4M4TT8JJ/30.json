[
    {
        "ts": "1542213101.104100",
        "text": "`skip-msys` は試したことなかったですね。\nなるほど。\nとはいえ、やること同じになりそう。\n今回は hsexif を使おうとしたら iconv に依存していたのでした",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1542213508.104300",
        "text": "今更気づいたんですが、iconv 不依存でビルドするフラグが用意されていた\n<https://www.stackage.org/haddock/lts-12.18/hsexif-0.6.1.6/Graphics-HsExif.html>",
        "user": "U4L0B71L1",
        "type": "message"
    },
    {
        "ts": "1542320147.104900",
        "text": "<@UE51MD4E6> has joined the channel",
        "user": "UE51MD4E6",
        "type": "message"
    },
    {
        "ts": "1542322668.105500",
        "text": "\"This book aims to be the comprehensive manual for type-level programming\" <https://leanpub.com/thinking-with-types/>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1542341440.105900",
        "text": "<@UE4JVGDRP> has joined the channel",
        "user": "UE4JVGDRP",
        "type": "message"
    },
    {
        "ts": "1542428355.107900",
        "text": "Dhall 移植作業、だいたいわかったので雑に作った\n<https://github.com/matsubara0507/yaml-to-dhall>",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1542596772.110100",
        "text": "DhallのC/C++バインディングって存在してないんですね。 `hsc2hs` でCとHaskellの型をそれぞれ生成して、C/C++からFFIすれば読めそうなイメージ",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1542596795.110600",
        "text": "Dhall布教のために、ちょっと検証してみましょうか",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1542598436.113100",
        "text": "…と思ったのですが、Haskellの `data` で定義した型をCから読めるようにするのは `hsc2hs` では出来なさそうでした",
        "user": "U570660KX",
        "type": "message"
    },
    {
        "ts": "1542603305.113800",
        "text": "Dhall のコメントアウトって冒頭しか残らないのか、フォーマッターとかで",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1542603505.114000",
        "text": "dhall format の仕様でそうなっていますね",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1542603613.115100",
        "text": "AST構築の関係でそうなっているっぽい？ <https://github.com/dhall-lang/dhall-haskell/issues/145>",
        "user": "U4M598NHM",
        "type": "message"
    },
    {
        "ts": "1542603962.116300",
        "text": "なるほどコメントアウトを保持して整えるのって大変なのか",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1542606084.116900",
        "text": "<https://taylor.fausak.me/2018/11/18/2018-state-of-haskell-survey-results/#>\nグラフとその下にある表のパーセンテージが全然噛み合ってないように見える（多分未回答の人の分もカウントしてるから？）から最初戸惑った。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1542682272.117300",
        "text": "<@UE7LADZQT> has joined the channel",
        "user": "UE7LADZQT",
        "type": "message"
    },
    {
        "ts": "1542694337.118100",
        "text": "各回のHaskell Dayのページを作っていただきました！\n<https://wiki.haskell.jp/Workshop/HaskellDay/2018>\n<https://wiki.haskell.jp/Workshop/HaskellDay/2016>\n<https://wiki.haskell.jp/Workshop/HaskellDay/2012>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1542770014.119700",
        "text": "Hasパターン使うと、env を共有できるのか（していいのかはわからないけど）",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1542785814.120000",
        "text": "<@UE8N92RKN> has joined the channel",
        "user": "UE8N92RKN",
        "type": "message"
    },
    {
        "ts": "1542797416.124500",
        "text": "Haskell-jpではプロジェクトのビルドといえばstackが定番ですが、最近cabal-installはNix-style local buildという、依存関係をプロジェクト単位で管理する仕組みが充実してきています。そこで、ディスク使用量削減も兼ねて私のstack関係のデータを全消しし、代わりにcabal new-buildでビルドしてみる、名付けて「脱stack計画」の実行を宣言します。このスレッドで経過を報告するのでお楽しみに",
        "user": "U4KUNQF9N",
        "type": "message"
    },
    {
        "ts": "1542807324.127200",
        "text": "ダツスタ",
        "user": "U56L7EVNY",
        "type": "message"
    },
    {
        "ts": "1542808571.128500",
        "text": "僕もしばらくcabal new-buildをメインに使っています。ライブラリを作る人は複数バージョンのGHCが試しやすいのでおすすめします。/opt/ghcにいろんなバージョンのGHCをインストールしてPATHを通しておき、-w ghc-8.6.2とオプションを渡すだけでバージョンを切り替えられて便利です。",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1542808902.131900",
        "text": "個人的な印象では不可解なビルドエラーに悩まされることがcabalの方が少ない、複数バージョンのGHCを切り替えやすい、backpackやパッケージ内複数ライブラリの対応など最新の機能がcabalから実装されること、プロファイルや最適化オプションの変更時などstackでは適切にリビルドしてくれないことが多かったことなどからnew-buildがメインになりました",
        "user": "U4M9NJ7QE",
        "type": "message"
    },
    {
        "ts": "1542813365.133100",
        "text": "実はstackしか使わず、cabal hellを伝え聞くだけの身としてcabalをなまで扱うのは恐れがあったりします",
        "user": "U7155GPR9",
        "type": "message"
    },
    {
        "ts": "1542834333.136700",
        "text": "そうそう意外と、cabalも昔ほど地獄じゃなくなったんですよね。 ただ、stackを使う利点だなと思ってる事は、stack.yaml が与えられらプロジェクトでは安定したビルドが得られる (allow-newer が指定されてる場合を除く)事だと思ってるんですよね。 まぁ、正確にはcabalだけでも同じ事は出来ますが、build-dependsを全部正確に書いてるプロジェクトをそこまで見た事ないですね。",
        "user": "U9XHWQX7Z",
        "type": "message"
    },
    {
        "ts": "1542837525.137600",
        "text": "cabalの場合はビルドが成功した時点でcabal new-freezeすると依存バージョンを固定できます",
        "user": "U4M9NJ7QE",
        "type": "message"
    }
]