[
    {
        "ts": "1532751333.000029",
        "text": "いつもお世話になります。並列処理時の設計について質問です。\n\n実行時に決定されるリスト xs と、そのリストの要素を引数とするIOアクション  f::x-&gt;IO()  があり、 mapConcurrently_  で並列化しました。\n\nここで、f が他のリストの要素に影響与えないように縛る(？)にはどうしたら良いでしょうか？  f の中ではxをキーとして複数の外部資源にアクセスしますが、例えば f のどこかで x+1 を使うというようなことを避けたい。これが守られない場合、並列で動かした時、デッドロックや外部資源上のデータの破損などが発生します。\n\nfは規模が大きくなって、複数の開発者が携わる可能性があります。「コードレビュー時に気をつける」という以上に、完璧でなくてもいいのですが、何らかの仕組みを考えたいです。\n\n以下、なけなしのhaskellの知識で考えた対策案ですが、よりhaskellらしい方法もあろうかと思います。よろしくお願いします。\n\n案１）f 内で使われる外部資源にアクセスする関数（例えば g::x-&gt;y-&gt;IO(),   y は更新したい内容）について、予めxを部分適用した g’  を、f に渡して、f内では直接 xに触らないようにする。この場合、fが大きくなると、部分適用した関数をあちこち取り回さないといけないので、ちょっと面倒な感じもします。\n\n案２）Readerモナドにxを入れて、外部資源にアクセスする関数は x をモナド経由で取り出す。Readerモナドは、ネストした関数に適用するときはlocalで上書きできてしまうので、localのないReaderモナドのようなものがあればいいのかもしれませんが、いまのところ探せていません。",
        "user": "U7GSVRQ6S",
        "type": "message"
    }
]