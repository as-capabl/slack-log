[
    {
        "ts": "1542858379.064700",
        "text": "例えば、\"Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t\"で検索したらlensパッケージのTraversalがヒットして欲しい、みたいな具合です",
        "user": "U7907NMGF",
        "type": "message"
    },
    {
        "ts": "1542859709.064900",
        "text": "型シノニムだけ結果に表示するようなオプションは見つけられませんでした…\n型変数名が同じなら Google は一応見つけてくれましたが、不便は不便ですね。\n<https://www.google.co.jp/search?q=%22Applicative+f+%3D%3E+%28a+-%3E+f+b%29+-%3E+s+-%3E+f+t%22>",
        "user": "U578W9676",
        "type": "message"
    },
    {
        "ts": "1542862734.065200",
        "text": "なるほど。。。Haddockに直接相談しないとどうにもならなさそうですね。。。 :disappointed_relieved:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1542877932.066700",
        "text": "この関数って安全ではない気がするんですが、型レベルの分岐が出来る仕組み (Type Families とか) がプリミティブじゃないので大丈夫、だったりするんですか？ <http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html#v:inner>",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1542882884.067200",
        "text": "これを見る限りは，value type constructorとtype functionは明確に区別されていて，primitiveのreflexive axiomはvalue type constructorのみに提供されているように見えますね(今はkind equalityが入ってるのでそっちで大丈夫なのか分からないですが)\n<https://www.microsoft.com/en-us/research/wp-content/uploads/2007/01/tldi22-sulzmann-with-appendix.pdf>",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1542915925.067500",
        "text": "<@UEBLMNJP8> has joined the channel",
        "user": "UEBLMNJP8",
        "type": "message"
    },
    {
        "ts": "1543138178.067700",
        "text": "ありがとうございます！読んでみます",
        "user": "U5LEE6C1J",
        "type": "message"
    },
    {
        "ts": "1543144528.068000",
        "text": "<@UEB8VS15H> has joined the channel",
        "user": "UEB8VS15H",
        "type": "message"
    },
    {
        "ts": "1543177906.072700",
        "text": "<@UEBAETNPM> has joined the channel",
        "user": "UEBAETNPM",
        "type": "message"
    }
]