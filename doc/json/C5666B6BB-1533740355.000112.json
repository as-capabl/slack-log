[
    {
        "ts": "1533728880.000218",
        "text": "以下のコードをビルドすると `Orphan instance: instance From Word8 HogeSerializeFormat` という警告が出てしまいます。\n<https://repl.it/repls/SilverIntentEmulator>\n`{-# OPTIONS_GHC -fno-warn-orphans #-}` をつければ警告を消せるようなのですが、そもそもこの警告は何が問題なのでしょうか？（実行時にエラーになる場合があるなど）\nネットで調べてみると `instance From Word8 HogeSerializeFormat` の部分のファイルを分ければよいということが書いてあったのですが、分けようとした（module Data.Word内に書いてみた）際に循環importになってしまいビルドができなくなってしまいました。\nhs-bootというものを使えば解決できると書いてあったのですが、僕の理解が間違っているのかhs-boot内でお互いをimportしてしまい、結局循環import問題が発生してしまいました。\n長くなりましたが、この問題はどう解決するのがベストなのでしょうか？ `{-# OPTIONS_GHC -fno-warn-orphans #-}` をつけて警告を消してしまってよいのか、それとも別の方法がよいのか。\nよろしくお願い致します。",
        "user": "UC42RRAVC",
        "type": "message"
    },
    {
        "ts": "1533730689.000201",
        "text": "&gt; `{-# OPTIONS_GHC -fno-warn-orphans #-}` をつければ警告を消せるようなのですが、そもそもこの警告は何が問題なのでしょうか？\n\n実行時エラーが起こると言うことはありません。\nこの警告は、\n- 「ある型クラスの定義」と「ある型に対するその型クラスのインスタンスの定義」\n- 「ある型の定義」と「その型に対するある型クラスのインスタンスの定義」\nがすべて別のモジュールに分かれてしまっている場合に起こります。\n今回の場合、\n```\ninstance From HogeSerializeFormat Word8\n```\nなどのインスタンスの定義が問題になっているわけですが、\nこれは、 `Word8` という型の定義と、 `From` という型クラスの定義、どちらのモジュールとも異なるモジュールで宣言しているから `Orphan instance` と言われてしまいます。\nインスタンスの定義だけが型クラスの定義からも型の定義からも離れた、 \"orphan\" （孤児）になってしまっているから \"Orphan instance\" といいます。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1533730937.000111",
        "text": "で、何が問題なのかというと、どのモジュールを import したらいいのかわかりづらくなってしまうという問題があります。\n`Word8` について `From` のインスタンスがあることを知っていても、 `Word8` が定義されたモジュール、 `From` が定義されたモジュール、どちらを import してもインスタンスが利用できないため、使おうとしたときに迷ってしまう恐れがあるのです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1533731623.000315",
        "text": "実際のところ、orphan instanceは意図的に定義されることもしばしばあります。\nそういう場合のために、警告として、無効にできるようになっているのです。\n例えばいろいろな型に使える、汎用性の高い型クラスを提供するパッケージAがあるとします。\nAの作者はできるだけいろいろな型をその型クラスのインスタンスにしようとしますが、実際にはあらゆる型をサポートできるわけではありません。\nAがリリースされた後に新しい、Aが提供する型クラスにふさわしい型がリリースされるなんてことは十分あり得ますし、そもそそもあらゆる型をサポートするために、Aの依存パッケージを増やすということは、できるだけ避けるべきです。\n\nそれでもAが提供する型クラスのインスタンスを、あの型にも提供したい！という場合に、orphan instance専用のパッケージが作られることがしばしばあります。\n「hogehoge-instances」なんて名前のパッケージがあったら、多くの場合そうしたorphan instance専門のパッケージです。\n探してみると面白いでしょう。\n<http://hackage.haskell.org/packages/search?terms=instances>",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1533731722.000262",
        "text": "今回の場合は、 `instance From HogeSerializeFormat Word8` などを `Data.From` モジュールに移動させれば、\n「ある型クラスの定義」と「ある型に対するその型クラスのインスタンスの定義」\nが同じモジュールに含まれるようになるため、問題ないはずです。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1533732128.000165",
        "text": "後で調べてわかったんですが、Coercibleはユーザーが自分でインスタンスを定義できるものではなく、GHCが自動でCoercibleかどうか判定するという非常に特殊なものなので、RustのFromとはずいぶん性格が違うようです。。。",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1533733975.000113",
        "text": "なるほど！ `Data.From` に移動すればよかったのですね！\n移動したところ警告が出ずにビルドすることができました！\n丁寧にご説明していただき、ありがとうございます！",
        "user": "UC42RRAVC",
        "type": "message"
    },
    {
        "ts": "1533740355.000112",
        "text": "Orphan instanceを避けるべき理由としては他に、ライブラリaとライブラリbがそれぞれ勝手にinstance宣言をして、それらが被っていると、それらを同じプロジェクトで使った時に問答無用で重複エラーになる、すなわちライブラリaとbを同時に使う事が出来なくなる、というのがありますね。なので、ライブラリでなくexeのソースでやる分には結構大丈夫なんじゃないかと思ったりします",
        "user": "U570660KX",
        "type": "message"
    }
]