[
    {
        "ts": "1531350000.000009",
        "text": "ありがとうございます！",
        "user": "U56G77VM1",
        "type": "message"
    },
    {
        "ts": "1531369895.000137",
        "text": "VSCodeでHaskell IDE engineを使用していると気づいたら5,6GBもメモリを消費しているのですが、これを回避する方法はありますか。いまのところは定期的にIDEを再起動してこれを回避しています。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1531370171.000115",
        "text": "現状は IDE を再起動するしかないと思います…。\n<https://github.com/haskell/haskell-ide-engine/issues/665>\n<https://github.com/haskell/haskell-ide-engine/issues/580>",
        "user": "U5B3EGEFQ",
        "type": "message"
    },
    {
        "ts": "1531370288.000023",
        "text": "なるほど。ありがとうございます。",
        "user": "U7Z4F723Z",
        "type": "message"
    },
    {
        "ts": "1531380475.000121",
        "text": "特定のインスタンスを持っている場合だけ処理を変えたいのですが、なにかやり方はありますでしょうか？\n具体的には、\n```\nfromIntegral :: (Num a, Integral i) =&gt; i -&gt; a\n```\nを拡張して、 `(Floating a, Bounded i)` の場合だけ、ノーマライズする処理を入れたいです。\n\n気分的にはこんなコードを動くようにしたいです。\n\n```\nclass FromIntegralNormalized i a where\n  fromIntegralNormalized :: i -&gt; a\n\ninstance (Integral i, Num a, Bounded i, Floating a) =&gt; FromIntegralNormalized i a where\n  fromIntegralNormalized = (/ fromIntegral (maxBound :: i)) . fromIntegral\n\ninstance (Integral i, Num a) =&gt; FromIntegralNormalized i a where\n  fromIntegralNormalized = fromIntegral\n```",
        "user": "U4LNDESN8",
        "type": "message"
    },
    {
        "ts": "1531401547.000108",
        "text": "基本的には，これをそのまま実現するのは難しいため，APIの見直しを推奨します．\n\nAPIそのままとはいきませんが，基本的にはGADTsを使って\n```\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\ndata WhetherNormalize i a where\n  BoundedNormalize :: (Bounded i, Floating a) =&gt; i -&gt; WhetherNormalize i a\n  WithoutNormalize :: i -&gt; WhetherNormalize i a\n\nfromIntegralWithNormalize :: forall i a. (Integral i, Num a) =&gt; WhetherNormalize i a -&gt; a\nfromIntegralWithNormalize (BoundedNormalize x) = fromIntegral x / fromIntegral (maxBound :: i)\nfromIntegralWithNormalize (WithoutNormalize x) = fromIntegral x\n```\nというのがいいと思います．\n\nこのような関数を多相化する場合，実行時まで制約が存在するかの判定を遅延する必要があります(要は，それぞれの制約をMaybeに包むことで多相を実現するイメージです)\nなお，一応この仕組みを単純に実現するコンパイラプラグインが提供されているみたいです\n<https://hackage.haskell.org/package/constraints-emerge>",
        "user": "U57D08Z9U",
        "type": "message"
    }
]