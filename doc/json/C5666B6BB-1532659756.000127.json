[
    {
        "ts": "1532656407.000100",
        "text": "どこのバグなのかよくわからないんですが、extensibleを使った :point_down: のコードでなぜか型エラーになってしまいます。\n```\n{-# OPTIONS_GHC -fno-warn-simplifiable-class-constraints #-}\n\n{-# LANGUAGE DataKinds         #-}\n{-# LANGUAGE FlexibleContexts  #-}\n{-# LANGUAGE OverloadedLabels  #-}\n{-# LANGUAGE OverloadedStrings #-}\n\nimport qualified Data.Extensible as E\nimport           Lens.Micro      ((^.))\n\nhoge\n    :: E.Associate \"pageId\" String e\n    =&gt; E.Record e\n    -&gt; IO ()\nhoge e = do\n    let (h : _) = (e ^. #pageId)\n    print (h :: Char)\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1532656434.000166",
        "text": "エラーは次のようなものです。\n\n```\ntest.hs:20:25: error:\n    • Couldn't match type ‘E.Elaborate\n                             \"pageId\" (E.FindAssoc 0 \"pageId\" e)’\n                     with ‘'E.Expecting (n0 'E.:&gt; [Char])’\n        arising from the overloaded label ‘#pageId’\n      The type variable ‘n0’ is ambiguous\n    • In the second argument of ‘(^.)’, namely ‘#pageId’\n      In the expression: (e ^. #pageId)\n      In a pattern binding: (h : _) = (e ^. #pageId)\n    • Relevant bindings include\n        e :: E.Record e (bound at test.hs:19:6)\n        hoge :: E.Record e -&gt; IO () (bound at test.hs:19:1)\n   |\n20 |     let (h : _) = (e ^. #pageId)\n   |                         ^^^^^^^\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1532657781.000095",
        "text": "いちよ，予想として書いておきます(合ってるかは分からないので，もうちょっとextensibleを使ってる人の意見があったらそっちを信用してもらいたいのですが)\nextensibleのキーとなるAssociateクラスやMemberクラスは，closed type familyとambiguousなcontextを使って，実現されています．つまり，今回の場合 `e` のどの位置に “pageId” があるかをtype familyで調べ，その位置をambiguousに型レベルの情報としてキャプチャし，それを用いてMembershipという情報を作ります．",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1532657905.000102",
        "text": "しかし，この方法は(Overlappingを使う手法も同じ問題があるのですが)，多相型(多相レコード)と非常に相性が悪いです(なぜなら多相型のままでは型レベルの位置情報を具体的に取り出せないため，GHCの型システム上では一意に決定できないからです)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1532658181.000030",
        "text": "なので，今回の場合Associate制約によってキャプチャされることが保証された位置情報と， `(^. #pageId)` (IsLabelの制約)で必要な位置情報が同じであることがGHCには分からず( `e` が多相であるため，位置情報を一意に決定できないため)，IsLabelの制約の方が位置情報が分からない（ `n0` は位置情報をGHCが一時的にmono化した変数で，この変数はAssociateの情報からキャプチャできるのですが，そのような推論をGHCからできないので怒られている)\nというのが原因だと思います",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1532658301.000141",
        "text": "解決策は，明示的に `Membership` 情報をAssociate制約から取ってきて( `association` メソッドを呼び出して)それを明示的に使用するか，Associate制約を使ったユーティリティを使用することだと思います(が，extensibleそんなに使ったことがないので，他に解決策があるかもしれません)",
        "user": "U57D08Z9U",
        "type": "message"
    },
    {
        "ts": "1532659062.000177",
        "text": "ありがとうございます！\n仮説通りの理由かどうかわかりませんが、:point_down: のように、 `e ^. #pageId` の結果を別の変数に束縛すると解決できました\n\n```\nhoge\n    :: E.Associate \"pageId\" String e\n    =&gt; E.Record e\n    -&gt; IO ()\nhoge e = do\n    let s :: String\n        s = e ^. #pageId\n        (h : _) = s\n    print (h :: Char)\n```",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1532659112.000039",
        "text": "ちょっと不思議なのは、 `(e ^. #pageId) :: String` と書いても同じエラーになってしまうんですよねぇ :disappointed:",
        "user": "U4LGTMTMK",
        "type": "message"
    },
    {
        "ts": "1532659756.000127",
        "text": "MonoLocalBindsを有効にするとできましたね．以下が通りました．ちょっとGHCのインスタンス解決の仕方の理解が間違ってたかもしれないです…こういう場合できるんですね…\n\n```\nhoge\n    :: E.Associate \"pageId\" String e\n    =&gt; E.Record e\n    -&gt; IO ()\nhoge e = do\n    let h :: Char\n         (h : _) = e ^. #pageId\n    print h\n```\n\n```\nhoge\n    :: E.Associate \"pageId\" String e\n    =&gt; E.Record e\n    -&gt; IO ()\nhoge e = do\n    let (h : _) = e ^. #pageId :: String\n    print h\n```\n\nMonoLocalBindsがない状態だと，IsLabelが解決できないようですね．",
        "user": "U57D08Z9U",
        "type": "message"
    }
]